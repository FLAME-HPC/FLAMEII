/*!
 * \file flame2/exe/task_splitter.cpp
 * \author Shawn Chin
 * \date 2012
 * \copyright Copyright (c) 2012 STFC Rutherford Appleton Laboratory
 * \copyright Copyright (c) 2012 University of Sheffield
 * \copyright GNU Lesser General Public License
 * \brief DESCRIPTION
 */
#include "flame2/config.hpp"
#include "task_splitter.hpp"

namespace flame { namespace exe {

TaskSplitter::TaskSplitter(Task::id_type id, const TaskVector& tasks)
    : id_(id), running_(0), next_(0), tasks_(tasks) {
  pending_ = tasks_.size();
}

// Returns true of no more pending or running tasks
bool TaskSplitter::IsComplete(void) const {
  return (running_ == 0 && pending_ == 0);
}

// Returns true if all tasks have been assigned
bool TaskSplitter::NonePending(void) const {
  return pending_ == 0;
}

// Decrements running_ and returns true if IsComplete()
bool TaskSplitter::OneTaskDone(void) {
#ifdef DEBUG
  if (running_ < 1) {
    throw flame::exceptions::flame_exception("None running");
  }
#endif
  --running_;
  return IsComplete();
}

// Decrements pending_ and returns true if NonePending()
bool TaskSplitter::OneTaskAssigned(void) {
#ifdef DEBUG
  if (pending_ < 1) {
    throw flame::exceptions::flame_exception("None pending");
  }
#endif
  --pending_;
  ++running_;
  return NonePending();
}

// Returns reference to the next task and decrements next_
Task& TaskSplitter::GetTask() {
#ifdef DEBUG
  if (next_ >= tasks_.size()) {
    throw flame::exceptions::flame_exception("All taken");
  }
#endif
  Task* t_ptr = tasks_[next_++].get();
  return *t_ptr;
}

// Returns the number of subtasks generated by split
size_t TaskSplitter::GetNumTasks(void) {
  return tasks_.size();
}

}}  // namespace flame::exe
