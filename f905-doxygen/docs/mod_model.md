Module - MODEL (Model Representation) {#modmodel}
=====================================

[TOC]

Models {#modmodel-models}
======

The [Model](@ref flame::model::Model) is a class that is used to construct models,
validate models and register agent functions. It is used by modellers to create models
using code and by the xparser to create code of models described in XML.
The underlying model information is held by the [XModel](@ref flame::model::XModel) class.

Creating Models {#modmodel-creating_models}
===============

The following methods are used to create a model:
 * [Model](@ref flame::model::Model::Model) - create a model object.
 * [addAgent(name)](@ref flame::model::Model::addAgent) - add an agent
   to the model with a specified name.
 * [addAgentVariable(agent_name, type, name)](@ref flame::model::Model::addAgentVariable) -
   add an agent variable to the named agent giving its type and name.
 * [AgentFunction(name, current_state, next_state)](@ref flame::model::AgentFunction::AgentFunction) -
   create an agent function object specifying the function name and its source and target states.
 * [addInput(name)](@ref flame::model::AgentFunction::addInput) - add an input to an agent function
   specifying the message name.
 * [addOutput(name)](@ref flame::model::AgentFunction::addOutput) - add an output to an agent function
   specifying the message name.
 * [addReadOnlyVariable(name)](@ref flame::model::AgentFunction::addReadOnlyVariable) -
   add read only access from an agent function to an agent variable specifying the variable name.
 * [addReadWriteVariable(name)](@ref flame::model::AgentFunction::addReadWriteVariable) -
   add read and write access from an agent function to an agent variable specifying the variable name.
 * [addAgentFunction(agent_name, agentFunction](@ref flame::model::Model::addAgentFunction) -
   add an agent function object to the model with a specified function name.
 * [registerAgentFunction(name, f_ptr)](@ref flame::model::Model::registerAgentFunction) -
   register a function using its pointer and the associated model function name.
 * [addMessage(name)](@ref flame::model::Model::addMessage) - add a message type
   to the model with a specified name.
 * [addMessageVariable(message_name, type, name)](@ref flame::model::Model::addMessageVariable) -
   add a message variable to the named message giving its type and name.
   
Validating Models {#modmodel-validating_models}
=================

A model is validated by calling [validate()](@ref flame::model::Model::validate) on a
[Model](@ref flame::model::Model) object. Only validated models can be added to a simulation.

The [XModelValidate](@ref flame::model::XModelValidate) class validates the underlying
[XModel](@ref flame::model::XModel) object.

The validation process includes creating graphs of the model:
 * While validating agents their state graphs are generated and
  * a single start state is checked,
  * cyclic dependencies are checked, and
  * function conditions on states with more than one outgoing transition are checked.
 * While validating the model the model state graph is generated where agent state graphs
   are combined.
 * If a model is validated then the model dependency graph is generated where each agent
   dependency graph is generated and then combined.

Model Graphs {#modmodel-model_graphs}
============

The [Boost Graph Library](http://www.boost.org/libs/graph) is used to hold and analyse graphs.
Three classes are used to make the process easier:
 * [XGraph](@ref flame::model::XGraph) - used to hold underlying graph representations.
 * [StateGraph](@ref flame::model::StateGraph) - used to hold state graphs.
 * [DependencyGraph](@ref flame::model::DependencyGraph) - used to hold dependency graphs.

[XGraph](@ref flame::model::XGraph) class contains:
 * A graph represented by a Boost [adjacency_list](http://www.boost.org/libs/graph/doc/using_adjacency_list.html) class.
 * A list of [ModelTask](@ref flame::model::ModelTask) objects using [TaskList](@ref flame::model::TaskList).
 * A mapping between graph edges and [Dependency](@ref flame::model::Dependency) objects.
 * Methods to add and remove vertices and edges.
 * Methods to probe edge sources and targets, and vertex in and out edges.
 * Methods to remove redundant vertices, check cyclic dependencies, and get a list of topologically sorted vertices.
 * Method to write out a graphviz file of the graph.

Generating State Graphs {#modmodel-generating_state_graphs}
-----------------------

State graphs are generated by each agent, for each transition function:
 * Create a new [ModelTask](@ref flame::model::ModelTask) for the agent function.
 * Add the [ModelTask](@ref flame::model::ModelTask) as a vertex to the graph.
 * Add the source and target states as vertices
 * Add function variable reads and writes, including condition reads to the source state
 * Add input and output communication, adding message vertices when needed

Model state graphs are generated by importing each agent state graph.
 
The infection model state graph shows vertices representing states, transition functions,
messages, and a condition function.

@img{images/infection_model/infection_stategraph.png, 10cm, State graph - Infection model}

Generating Dependency Graphs {#modmodel-generating_dependency_graphs}
----------------------------

Dependency graphs are generated by each agent by the following steps:
 1. Start with initial agent state diagram
 2. Transform states with conditional outgoing transitions into condition functions and contract all the remaining state vertices and replace with state dependencies
 3. Analyse data reading and writing and add corresponding data dependencies and add variable output tasks from last writing functions
 4. Contract variable vertices and remove the state dependencies as these no longer hold function ordering 
 5. Remove redundant dependencies to achieve final dependency graph

@img{images/infection_model/Person_1.png, 3cm, Step 1 - Start with initial agent state diagram}

@img{images/infection_model/Person_2.png, 3cm, Step 2 - States contracted and condition functions added}

@img{images/infection_model/Person_3.png, 5cm, Step 3 - Add data flow and variable output}

@img{images/infection_model/Person_4.png, 3cm, Step 4 - Remove state dependencies and contract data vertices}

@img{images/infection_model/Person_5.png, 3cm, Step 5 - Remove redundant dependencies to form final dependency graph}

All agent dependency graphs are joined to create the model dependency graph, using the following steps:
 1. Create model start and finish tasks (these are used to setup and close any output files)
 2. Add all vertices and edges linking the model start task to agent start tasks and output tasks to the model finish task
 3. Contract agent start tasks
 4. Change agent message tasks to model message sync tasks and add message clear tasks

@img{images/infection_model/infection_dependencygraph.png, 15cm, Dependency graph - Infection model}
