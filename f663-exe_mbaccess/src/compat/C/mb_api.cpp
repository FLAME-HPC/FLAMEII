/*!
 * \file src/compat/mb_api.cpp
 * \author Shawn Chin
 * \date October 2012
 * \copyright Copyright (c) 2012 STFC Rutherford Appleton Laboratory
 * \copyright Copyright (c) 2012 University of Sheffield
 * \copyright GNU Lesser General Public License
 * \brief Mock Implementation of C API for message board access
 * \note These routines should instead be generated by the parser for each model
 */
#include <string>
#include "boost/ptr_container/ptr_map.hpp"
#include "include/flame.h"
#include "mb/client.hpp"
#include "mb/message.hpp"
#include "mb/message_iterator.hpp"

/* NOTE: This should not reflect the final implementation. This is a quick hack
 * to get the prototype running without a working parser.
 */

namespace m = flame::mb;

class IteratorWrapper {
  public:
    IteratorWrapper(m::MessageIteratorHandle handle) : handle_(handle) {}
    virtual ~IteratorWrapper() {}
    bool AtEnd(void) { return handle_->AtEnd(); }
    bool Next(void) { return handle_->Next(); }
    virtual void GetMessage(void* out_ptr) = 0;
  protected:
    m::MessageIteratorHandle handle_;
};

template <typename T>
class IteratorWrapperImpl : public IteratorWrapper {
  public:
    IteratorWrapperImpl(m::MessageIteratorHandle handle)
        : IteratorWrapper(handle) {}

    void GetMessage(void* out_ptr) {
      T* out = static_cast<T*>(out_ptr);
      *out = handle_->Get<T>(FLAME_MESSAGE_VARNAME);
    }
};


class TypeResolver {
  public:
    TypeResolver(std::string name) : name_(name) {}
    virtual ~TypeResolver() {}
    virtual void Post(void* mb, void* msg_ptr) = 0;
    virtual IteratorWrapper* GetMessages(void* mb, const char* msg) = 0;

  protected:
    std::string name_;
};

template <typename T>
class TypeResolverImpl : public TypeResolver {
  public:
    TypeResolverImpl(std::string name) : TypeResolver(name) {}

    void Post(void* mb, void* msg_ptr) {
      T* actual_ptr = static_cast<T*>(msg_ptr);
      m::Client* client = static_cast<m::Client*>(mb);
      m::MessageHandle msg = client->NewMessage(name_);
      msg->Set<T>(FLAME_MESSAGE_VARNAME, *actual_ptr);
      msg->Post();
    }

    IteratorWrapper* GetMessages(void* mb, const char* msg) {
      m::Client* client = static_cast<m::Client*>(mb);
      return new IteratorWrapperImpl<T>(client->GetMessages(msg));
    }
};

typedef boost::ptr_map<std::string, TypeResolver> TypeMap;
TypeMap type_map;

template <typename T>
void RegisterMessageType(std::string name) {
  std::string key = name;
  type_map.insert(key, new TypeResolverImpl<T>(name));
}


#ifdef __cplusplus
extern "C" {
#endif

void flame_mb_api_hack_initialise(void) {
  RegisterMessageType<location_message>("location");
}

void flame_msg_post_actual(void* mb, const char* k, void* v) {
  TypeMap::iterator iter = type_map.find(k);
  if (iter == type_map.end()) {
    throw flame::exceptions::invalid_argument("Message not registered in "
                                              "src/compat/C/mb_api.cpp "
                                              "(yes, this is a hack)");
  }
  iter->second->Post(mb, v);
}

flame_msg_iterator flame_msg_get_iterator_actual(void* mb, const char* msg) {
  TypeMap::iterator iter = type_map.find(msg);
  if (iter == type_map.end()) {
    throw flame::exceptions::invalid_argument("Message not registered in "
                                              "src/compat/C/mb_api.cpp "
                                              "(yes, this is a hack)");
  }
  return static_cast<flame_msg_iterator>(iter->second->GetMessages(mb, msg));
}

int flame_msg_iterator_next(flame_msg_iterator iter) {
  return static_cast<IteratorWrapper*>(iter)->Next();
}

int flame_msg_iterator_end(flame_msg_iterator iter) {
  return static_cast<IteratorWrapper*>(iter)->AtEnd();
}

void flame_msg_iterator_free(flame_msg_iterator iter) {
  delete static_cast<IteratorWrapper*>(iter);
}

void flame_msg_iterator_get_message(flame_msg_iterator iter, void* m_ptr) {
  static_cast<IteratorWrapper*>(iter)->GetMessage(m_ptr);
}

#ifdef __cplusplus
}
#endif
