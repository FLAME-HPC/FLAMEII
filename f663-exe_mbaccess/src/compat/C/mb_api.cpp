/*!
 * \file src/compat/mb_api.cpp
 * \author Shawn Chin
 * \date October 2012
 * \copyright Copyright (c) 2012 STFC Rutherford Appleton Laboratory
 * \copyright Copyright (c) 2012 University of Sheffield
 * \copyright GNU Lesser General Public License
 * \brief Mock Implementation of C API for message board access
 * \note These routines should instead be generated by the parser for each model
 */
#include <string>
#include "boost/ptr_container/ptr_map.hpp"
#include "include/flame.h"
#include "mb/client.hpp"
#include "mb/message.hpp"

/* NOTE: This should not reflect the final implementation. This is a quick hack
 * to get the prototype running without a working parser.
 */

namespace m = flame::mb;

class TypeResolver {
  public:
    TypeResolver(std::string name) : name_(name) {}
    virtual ~TypeResolver() {}
    virtual void Post(void* mb, void* msg_ptr) = 0;

  protected:
    std::string name_;
};

template <typename T>
class TypeResolverImpl : public TypeResolver {
  public:
    TypeResolverImpl(std::string name) : TypeResolver(name) {}

    void Post(void* mb, void* msg_ptr) {
      T* actual_ptr = static_cast<T*>(msg_ptr);
      m::Client* client = static_cast<m::Client*>(mb);
      m::MessageHandle msg = client->NewMessage(name_);
      msg->Set<T>(FLAME_MESSAGE_VARNAME, *actual_ptr);
      msg->Post();
    }
};

typedef boost::ptr_map<std::string, TypeResolver> TypeMap;
TypeMap type_map;

template <typename T>
void RegisterMessageType(std::string name) {
  std::string key = name;
  type_map.insert(key, new TypeResolverImpl<T>(name));
}

#ifdef __cplusplus
extern "C" {
#endif

void flame_mb_api_hack_initialise(void) {
  RegisterMessageType<location_message>("location");
}

void flame_msg_post_actual(void* mb, const char* k, void* v) {
  TypeMap::iterator iter = type_map.find(k);
  if (iter == type_map.end()) {
    throw flame::exceptions::invalid_argument("Message not registered in "
                                              "src/compat/C/mb_api.cpp "
                                              "(yes, this is a hack)");
  }
  iter->second->Post(mb, v);
}

int flame_msg_iterator_end(flame_msg_iterator iter) {
  mb::MessageIterator* iptr = static_cast<mb::MessageIterator*>(iter);
  return iptr->Next();
}

#ifdef __cplusplus
}
#endif
